from tkinter import *
from tkinter import ttk
from math import sqrt
from array import *
import random

class block:
	def __init__(self, position, blockType):
		if blockType == 'B':
			self.blocked = True
		else:
			self.blocked = False
		if blockType == 'H':
			self.highway = True
		else:
			self.highway = False
		if blockType == 'T':
			self.traverse = True
		else:
			self.traverse = False
		if blockType == 'N':
			self.normal = True
		else:
			self.normal = False
		self.x = position[0]
		self.y = position[1]

def createGrid(c, r, content, inNum):
	root = Tk()
	root.title('Grid')
	root.geometry("800x700")

	# Create A Main frame
	main_frame = Frame(root)
	main_frame.pack(fill=BOTH,expand=1)

	# Create Frame for X Scrollbar
	sec = Frame(main_frame)
	sec.pack(fill=X,side=BOTTOM)

	# Create A Canvas
	my_canvas = Canvas(main_frame)
	my_canvas.pack(side=LEFT,fill=BOTH,expand=1)

	# Add A Scrollbars to Canvas
	x_scrollbar = ttk.Scrollbar(sec,orient=HORIZONTAL,command=my_canvas.xview)
	x_scrollbar.pack(side=BOTTOM,fill=X)
	y_scrollbar = ttk.Scrollbar(main_frame,orient=VERTICAL,command=my_canvas.yview)
	y_scrollbar.pack(side=RIGHT,fill=Y)

	# Configure the canvas
	my_canvas.configure(xscrollcommand=x_scrollbar.set)
	my_canvas.configure(yscrollcommand=y_scrollbar.set)
	my_canvas.bind("<Configure>",lambda e: my_canvas.config(scrollregion= my_canvas.bbox(ALL))) 

	# Create Another Frame INSIDE the Canvas
	second_frame = Frame(my_canvas)

	# Add that New Frame a Window In The Canvas
	my_canvas.create_window((0,0),window= second_frame, anchor="nw")


	#-------------------------------------------------------------------------------------------
	#Drawing the Grid (sqaures, vertices, start)
	gridT = [] #grid indicating square type
	gridP = [] #grid that shows each square's probability at previous iteration
	gridCP = [[0]*r for i in range(c)] #grid that shows each square's probability at current iteration
	probN = 0 #probability of agent in normal block
	probH = 0 #probability of agent in highway block
	probT = 0 #probability of agent in "hard to traverse"
	blockedCount = 0 #total num of blocked blocks

	#i represents the current grid square, used to check square's boolean var
	i = 2
	for x in range(0, c):
		for y in range(0, r):
			cx, cy, b, h, t = content[i].split()
			x1 = ((int(cx)-1) * 50 + 25)
			y1 = ((int(cy)-1) * 50 + 25)
			x2 = (y1 + 50)
			y2 = (x1 + 50)
			b = b.strip()
			my_canvas.create_rectangle(x1,y1,y2,x2)
			if b == '1': #square is blocked
				my_canvas.create_rectangle(x1,y1,y2,x2,fill='gray')
			if h == '1': #square is highway
				my_canvas.create_rectangle(x1,y1,y2,x2,fill='yellow')
			if t == '1': #square is "hard to traverse"
				my_canvas.create_rectangle(x1,y1,y2,x2,fill='purple')
			i = i + 1
			my_canvas.create_rectangle(x1,y1,y2,x2)
	
	#counting blocked squares
	i = 2
	for x in range(0, c):
		for y in range(0, r):
			cx, cy, b, h, t = content[i].split()
			b = b.strip()
			if b == '1': #square is blocked
				blockedCount = blockedCount + 1
			i = i + 1

	i = 2
	for co in range(0, c):
		tmp_arrT = []
		tmp_arrP = []
		for ro in range(0, r):
			cx, cy, b, h, t = content[i].split()
			if b == '1': #if bool == 1, then square is blocked
				tmp_arrT.append('B')
				tmp_arrP.append(0)
			elif h == '1':
				tmp_arrT.append('H')
				tmp_arrP.append(1/(r*c - blockedCount))
				probH = probH + 1/(r*c-blockedCount) #adding up probability of initiating on H
			elif t == '1':
				tmp_arrT.append('T')
				tmp_arrP.append(1/(r*c - blockedCount))
				probT = probT + 1/(r*c-blockedCount)
			else:
				tmp_arrT.append('N')
				tmp_arrP.append(1/(r*c - blockedCount))
				probN = probN + 1/(r*c-blockedCount)
			i = i + 1
		gridT.append(tmp_arrT)
		gridP.append(tmp_arrP)
	
	#labelling x axis
	for x in range(0, c):
		text = my_canvas.create_text(x * 50 + 50, 10, text=x+1, tags="text")
		# my_canvas.update()

	#labelling y axis
	for y in range(0, r):
		text = my_canvas.create_text(10, y * 50 + 50, text=y+1, tags="text")

	# Create a list of block objects
	blk_lst = []
	for i in range(c):
		for j in range(r):
			temp_block = block([i+1, j+1], gridT[i][j])
			blk_lst.append(temp_block)

	for i in range(1):
		f = open(f'InfoFile{i}ForMap{inNum}.txt', "x")
		startx = random.randint(1, c)
		starty = random.randint(1, r)
		while blk_lst[startx*starty - 1].blocked == True: #change coords if starting block is blocked
			startx = random.randint(1, c)
			starty = random.randint(1, r)
		f.write("(x0, y0) = (" + str(startx) + "," + str(starty) + ")\n")
		f.write("(xi, yi):\n")
		curx = startx
		cury = starty
		moveArr = []
		sensorArr = []
		for inc in range(10): #generating ground truth states
			move = random.randint(1, 4) #1 = U, 2 = L, 3 = D, 4 = R
			moveChar = ' '
			oldx = curx
			oldy = cury
			#updating coords
			if move == 1:
				moveChar = 'U'
				if cury != 1:
					cury = cury - 1
			if move == 2:
				moveChar = 'L'
				if curx != 1:
					curx = curx - 1
			if move == 3:
				moveChar = 'D'
				if cury != r:
					cury = cury + 1
			if move == 4:
				moveChar = 'R'
				if curx != c:
					curx = curx + 1
			moveFail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1] # 10% chance of move failing
			movef = random.choice(moveFail)
			#if movef == 1:
				#print("fail")
			if gridT[curx - 1][cury - 1] == 'B' or movef == 1: #checking if its trying to move to a blocked block
				#print("blocked")
				curx = oldx
				cury = oldy
			moveArr.append(moveChar)
			#print("*" + str(curx) + " " + str(cury) + "*")
			f.write("(" + str(curx) + "," + str(cury) + ")\n")
		
			actualType = 'N'
			otherTypes = ['H', 'T']
			if gridT[curx - 1][cury - 1] == 'H':
				actualType = 'H'
				otherTypes = ['N', 'T']
			if gridT[curx - 1][cury - 1] == 'T':
				actualType = 'T'
				otherTypes = ['N', 'H']
			print(actualType)
			senseFail1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] #5% chance of failing and sensing other type
			senseFail2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] 
			senseF1 = random.choice(senseFail1)
			senseF2 = random.choice(senseFail2)
			if senseF1 == 1:
				print("fail1" + otherTypes[0])
				sensorArr.append(otherTypes[0])
			elif senseF2 == 1:
				print("fail2" + otherTypes[1])
				sensorArr.append(otherTypes[1])
			else:
				sensorArr.append(actualType)
					
		

		#generating actions
		f.write("a:\n")
		for inc in range(10):
			f.write(moveArr[inc] + "\n")

		#generating sensor readings
		f.write("e:\n")
		for inc in range(10):
			f.write(sensorArr[inc] + "\n")

		f.close()
	#for x in range(c):
		#for y in range(r):
			#x1 = (x * 50 + 20)
			#x2 = (x1 + 10)
			#y1 = (y * 50 + 20)
			#y2 = (y1 + 10)
			#text = my_canvas.create_text(x1 + 20, y1 + 12, font=("Helvetica", 10), text=gridP[x][y], tags="text")

	#textnum = input('Enter the number of the ground truth file that you want to run: ')
	#print(textnum)
	#finding probability when direction is R and blocktype is N
	direction = 'R'
	blockType = 'N'
	typeProb = probN 
	for x in range(c):
		for y in range(r):
			x1 = (x * 50 + 20)
			x2 = (x1 + 10)
			y1 = (y * 50 + 20)
			y2 = (y1 + 10)
			gridCP[x][y] = calcProb(x, y, r, c, direction, blockType, typeProb, gridT, gridP)#changed
			text = my_canvas.create_text(x1 + 20, y1 + 12, font=("Helvetica", 10), text=gridCP[x][y], tags="text")
	print(probN)
	print(probH)
	print(probT)
	root.resizable(True, True)
	root.mainloop()

def calcProb(x, y, r, c, direction, blockType, typeProb, gridT, gridP):
	#T represents block type, C represents {x,y})
	#given the agent is at {x,y}, calc1 is the probability of correct reading
	#= P(E = T|X = C)'
	#{prevx, prevy} represents X0 when X0 is not {x,y}, but X1 is {x,y}
	prevx = 0
	prevy = 0
	if direction == 'U':
		if y != 1:
			prevy = prevy - 1
	if direction == 'L':
		if x != 1:
			prevx = prevx - 1
	if direction == 'D':
		if y != r:
			prevy = prevy + 1
	if direction == 'R':
		if x != c:
			prevx = prevx + 1
	prevProb = gridP[prevx][prevy]
	calc1 = .1*(gridP[x][y]) + .9*(gridP[prevx][prevy])*(1-gridP[x][y]) 
	
	#given agent is at {x,y}, chance of reading is correct = P(E = T|X = C)
	if gridT[x][y] == blockType:
		calc1 = round(calc1 * .9, 2)
	elif gridT[x][y] == 'B':
		calc1 = round(calc1 * 0.0, 2)
	else:
		calc1 = round(calc1 * .05, 2)
	#given agent is at {x,y}, chance of reading is correct = P(E = T|X = C)

	#given that the reading is right, calc2 is probability of agent not being at {x,y}
	#= P(X != C|E = T)
	calc2 = 0
	if gridT[x][y] != 'B': #0 chance if blocked
		calc2 = typeProb
	#given agent is not at {x,y}, chance of reading is correct = P(E = T|X = C)
	if gridT[x][y] == blockType:
		calc2 = calc2 - gridP[x][y]
	#given agent is not at {x,y}, chance of reading is correct = P(E = T|X = C)

	#given agent was prev not at {x,y}, chance of agent currently not at {x,y} = P(X1 != D|X0 != D)
	moveProb = 0 #calculating prob of agent moving and P(X1 != C|X0 != C) = True
	moveProb = .9*(1 - gridP[prevx][prevy] - gridP[x][y])
	stayProb = 0 #calculating prob of agent staying and P(X1 != C|X0 != C) = True
	stayProb = .1*(1 - gridP[x][y])
	#given agent was prev not at {x,y}, chance of agent currently not at {x,y} = P(X1 != D|X0 != D)
		
	calc2 = calc2*(.9*gridP[x][y] + (moveProb + stayProb)*(1-gridP[x][y]))

	return round(calc2,2)

def main():
	textnum = input('Enter the number of the testcase that you want to run: ')
	testFile = open(f'testcase{textnum}.txt', "r")
	content = testFile.readlines()
	col, row = content[1].split()
	createGrid(int(col), int(row), content, textnum)
	#createProb(int(col), int(row), context, textnum)
main();
